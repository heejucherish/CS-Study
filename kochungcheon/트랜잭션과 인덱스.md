# DB



## 트랜잭션

- 트랜잭션이란??

  데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위 (최소 단위)

  상태변화는 SQL을 이용하여 데이터 베이스에 접근하는 것을 의미한다.



- 트랜잭션의 특징 ACID

  1. 원자성(Aztomicity)

     트랜잭션이 데이터베이스에 모두 반영되거나 모두 반영되지 않아야 한다는 것이다.

     트랜재션은 사람이 설계한 논리한 작업의 단위인데, 일처리가 작업단위 별로 이루어 져야 사람이 다루는 데 무리가 없다. 만약에 트랜잭션 단위로 데이터가 처리되지 않는 다면, 설계한 사람은 데이터 처리 시스템을 이해하기 힘들 뿐 아니라, 오작동 했을시 찾기가 매우 힘들어진다.

  2. 일관성(Consistency)

     트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다는 것이다. 트랜잭션이 진행되는 동안 데이터 베이스가 변경되더라도 업데이트된 데이터 베이스로 트랜잭션이 진행되는 것이 아니라 처음에 트랜잭션을 진행 하기 위해 참조한 데이터 베이스로 진행된다.

     이렇게 해서 사용자는 일관성 있는 데이터를 볼 수 있는 것이다.

  3. 독립성(Isolation)

     둘 이상의 트랜잭션이 동시에 실행되고 있을 경우 어떤 하나의 트랜잭션이라도, 다른 트랜잭션의 연산에 끼어들수 없다는 점을 가리킨다. 하나의 트랜잭션이 완료될 때 까지, 다른 트랜잭션이 특정 트랜잭션의 결과를 참조할 수 없다. 

  4. 지속성(Durability)

     트랜잭션이 성공적으로 완료됬을 경우, 결과는 영구적으로 반영되어야 한다는 것을 가리킨다.



- Locking 잠금기법에 대해 설명하세요

잠금은 하나의 트랜잭션이 실행하는 동안 특정 데이터 항목에 대해서 다른 트랜잭션이 동시에 접근하지 못하도록 상호배제 기능을 제공하는 기법.

하나의 트랜잭션이 데이터 항목에 잠금을 설정하면 잠금을 설정한 트랜잭션이 해제 할때까지 데이터를 독점적으로 사용할 수있다.

잠금 사용되는 연산에는 lock 연산과 unlock연산을 사용한다.



- s lock

  *공유잠금을 설정한 트랜잭션은 데이터 항목에 대해 읽기 연산(read)만 가능하다.*

- x lock

  *배타잠금을 설정한 트랜잭션은 데이터 항목에 대해서 읽기 연산(read)과 쓰기 연산(write) 모두 가능하다.*

​		가장 대표적인 동시성 제어 기법 

​		동시성 제어란 다중 사용자 환경을 지원하는 데이터 베이스 시스템에서 동시에 실행되는 여러 트랜잭션 간의 간섭으로 문제가 발생하지않도록 트랜잭션의 실행 순서를 제어하는 기법이다.

동시성 제어가 되지 않으면 갱신 분실, 연쇄 복귀 or 회복 불가능, 불일치 분석과 같은 문제가 생길 수 있다.

갱신 분실

트랜잭션들이 동일한 데이터를 동시에 갱신하는 경우에 발생, 또는 이전 트랜잭션이 데이터를 갱신한 후 트랜잭션이 종료하기 전에 나중 트랜잭션이 동일한 데이터를 갱신하여 갱신하여 갱신 값을 덮어쓰는 경우에 발생하는 문제.

연쇄 복귀 or 회복 불가능

여러 개의 트랜잭션이 데이터를 공유할 때, 특정 트랜잭션이 이전 상태로 복귀할 경우 아무 문제없는 다른 트랜잭션까지 연달아 복귀하게 되는 문제. 이때 한 트랜잭션이 이미 완료된 상태라면 트랜잭션의 지속성 조건에 따라 복귀 불가능

불일치 분석

여러 개의 트랜잭션이 동시에 실행할 때 끼어들기로 인해 트랜잭션의 일관성이 유지되지 못하는 상황



- 잠금 기법의 문제점에 대해 설명하세요.

​		직렬 가능한 스케줄이 항상 보장되지 않는 다.(병렬로 이루어 질 수도 있다.) -> 2단계 잠금 규약으로 해결 가능

​	그래서 교착상태가 발생할수 있다.

2PL은 **잠금을 설정하는 단계**와 **해제하는 단계**로 나누어 수행한다.

**확장단계(growing phase)** : 트랜잭션이 lock 연산만 수행할 수 있고 unlock 연산은 수행할 수 없는 단계

**축소단계(shrinking phase)** : 트랜잭션이 unlock 연산만 수행할 수 있고 lock 연산은 수행할 수 없는 단계



## 인덱스

- 인덱스란?

  테이블의 동작 속도를 높여주는 자료구조를 말한다. 인덱스는 테이블 내의 1개의 컬럼 혹은 여러 개의 컬럼을 이용하여 생성 될수 있다. 인덱스를 생성하면 해당 컬럼의 데이터를 정렬한 후 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장된댜. 컬럼값과 물리적 주소를 key value 형태로 저장한다.

  

  

- 인덱스 자료 구조

  해시 테이블 (시간 복잡도 O(1))

  키 벨류 항쌍으로 데이터를 저장하는 자료 구조

  다만 잘 사용되지는 않는 다 해시 테이블은 등호 (=)연산에 최적화 되기 때문이다. 데이터 베이스에는  부등호(<,>) 연산이 자주 사용 되는 데 해시 테이블 내의 데이터들은 정렬되어 있지 않으므로 특정 기준보다 크거나 작은 값을 빠른 시간 내에 찾을 수가 없다.

​		

​		B+tree (시간 복잡도 O(logN))

​		오직 leaf node 에만 데이터를 저장하고 leaf node 가 아닌 node 에서는 자식 포인터만 저장한다. 그리고 leaf node끼리는 linked list로 연결되어있다. 또, b+tree에서는 반드시 leaf node 에만 데이터가 저장되어 중간 node 에서 key를 올바르게 찾아가기 위해 key가 중복 될 수 있다. 

장단점

**1. leaf node를 제외하고 데이터를 저장하지 않기 때문에 메모리를 더 확보할 수 있다. 따라서 하나의 node에 더 많은 포인터를 가질 수 있기 때문에 트리의 높이가 더 낮아지므로 검색 속도를 높일 수 있다.** 

 

**2. Full scan을 하는 경우 B+Tree는 leaf node에만 데이터가 저장되어 있고, leaf node끼리 linked list로 연결되어 있기 때문에 선형 시간이 소모된다. 반면 B-Tree는 모든 node를 확인해야 한다.** 

 

반면, B-Tree의 경우 최상의 경우 특정 key를 root node에서 찾을 수 있지만, **B+Tree의 경우 반드시 특정 key에 접근하기 위해서 leaf node까지 가야 하는 단점이 있다.** 

 

인덱스에서 B-Tree 대신 주로 B+Tree를 사용하는 이유는 뭘까?

해시 테이블에서 언급했듯이 **인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생할 수 있다.** 따라서 B+Tree의 Linked list를 이용하면 순차 검색을 효율적으로 할 수 있게 된다. 



- 모든 칼럼에 index를 사용하면 좋나요?

​	인덱스를 관리하기 위한 추가 작업이 필요하고 추가 저장 공간이 필요함으로 반드시 필요한 곳이 아니면 안쓰는 것이 좋다.  안댁스의 수정의 경우 제거가 아니라 사용하지 않음으로 처리하고 남겨두기때문에 수정 작업이  많은경우 실제 데이터에 비해 인덱스가 과도 하게 커질수있고 별도의 메모리 공간에 저장되어 추가 저장공간이 많이 필요하다. 그리고 나이난 성별과 같이 값의 범위가 적은 컴럼인 경우 인덱스를 읽고 나서 다시 많은  데이터를 조회 하기 때문에 비효율적이다.



- 인덱스를 사용시 장단점과 사용하면 좋은 경우

  사용하면 좋은 경우는 데이터의 범위가 크고 중복이 적을수록(주소같은) 조회가 많거나 정렬된 상태가 유용한 컬럼에 사용하는 것이 좋다. 즉 큐모가 큰 테이블 

  삽입 수정 삭제 작업이 자주 발생하지 않는 컬럼 where order by join 등이 사용되는 컬럼 데이터의 중복도가 낮은 컬럼에 사용하면 좋다. 

  인덱스의 장단점으로는 

  테이블을 검색하는 속도와 성능이 향상된다. 인덱스에 의해 데이터들이 정렬된 형태를 갖는 것이다. 

​		단점으로는 인덱스를 관리하기위한 추가 작업이 필요하고, 추가 저장공간이 필요하고, 잘못 사용하는 경우 오히려 검색 성능 저하가 된다.





