# 운영 체제 면접 스터디 2차



## 메모리 관리 전략

- 교착상태(DeadLock)이 무엇이며 4가지 조건은?

​		어떤 프로세스가 자원을 요청 했을 때 그 시각에 그 자원을 사용할 수 없는 상황이 발생할    		수 있고 그때에는 프로세스가 대기 상태로 들어 간다.

​		대기상태로 들어간 프로세스들이 실행 상태로 변경 될 수 없을 때 교착상태라고 한다.	

​		한정된 자원을 여러 곳에서 사용하려고 할 때 발생할 수 있다. 

​	    대표적인 예로는 다음과 같다. 

​		멀티 프로그래밍 환경에서 한정된 자원을 사용하려고 서로 경쟁하는 상황

​		

​		발생조건

​		교착상태는 시스템 내에서 다음 네 가지 조건이 동시에 성립할 때 발생한다.

​		즉, 교착상태를 해결하기 위해선 하나라도 성립 않도록 하면 된다

  1. 상호 배제

     자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다.

  2. 점유대기

     최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기 하는 프로세스가 있어야한다.

3. 비선점

   다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다.

4. 순환 대기 

   프로세스 집합{p0, p1, p2..pn}에서 p0는 p1이 점유한 자원을 대기하고 p1은 p2가 점유한 자원을 대기하고 p2...pn-1은 pn이 점유한 자원을 대기하며 pn은 p0가 점유한 자원을 요구해야한다



데드락 처리

1. 교착 상태 예방 및 회피

   교착 상태가 되지 않도록 보장하기 위하여 교착 상태를 예방하거나 회피하는 프로토콜을 이용하는 방법

2. 교착 상태 탐지 및 회복

   교착 상태가 되도록 허용한 다음 회복시키는 방법

3. 교착 상태 무시

   대부분의 시스템은 교착 상태가 잘 발생하지 않으며 교착 상태 예방 회피 탐지 복구에 비용이 많이 든다 그러므로 무시



교착 상태 예방

​	교착 상태 발생 조건 중 하나를 제거 함으로써 해결하는 방법

​	자원의 낭비가 심하다

1. 상호배제 부정: 여러 개의 프로세스가 공유 자원을 사용할 수 있도록 한다.
2. 점유대기 부정: 프로세스가 실행 되기전 필요한 모든 자원을 할당한다.
3. 비선점 부정: 자원을 점유하고 있는 프로세스가 다른 자원을 요구 할 때 점유하고 있는 자원을 반납하고 요구한 자원을 사용하기 위해 기다리게 한다.
4. 순환 대기 부정: 자원에 고유한 번호를 할당하고 번호 순서대로 자원을 요구한다



교착 상태 회피 

​	교착 상태가 발생하면 피해나가는 방법

​	은행원 알고리즘

​		프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되		는지를 사전에 검사하여 회피하는 기법 안정 상태에 있으면 자원을 할당 그렇지 않으면 		다른 프로세스들이 자원을 해지할 때 까지 대기



교착 상태 탐지

​	자원 할당 그래프를 통해 교착 상태를 탐지할 수 있다.

​	자원을 요청할 때마다 탐지 알고리즘을 실행하면 오버헤드가 발생한다.



교착 상태로부터 회복 

​	교착 상태를 일으킨 프로세스를 종료하거나 할당된 자원을 해제함으로써 회복하는 것을 의	미한다

​	

​	프로세스를 종료하는 법

1. 교착 상태의 프로세스 모두 중지
2. 교착 상태가 제거 될 때 까지 한 프로세스씩 중지

​	

​	자원을 선점하는 방법

1. 교착 상태의 프로세스가 점유하고 있는 자원을 선점하여 다른 프로세스에게 할당하	며, 해당 프로세스를 일시 정지 시키는 방법
2. 우선 순위가 낮은 프로세스, 수행된 횟구가 적은 프로세스 등을 위주로 프로세스의 자원을 선점

- 외부 단편화와 내부 단편화

  메모리의 단편화 

  RAM에서 메모리의 공간이 작은 조각으로 나뉘어져 사용가능한 메모리가 충분히 존재하지만 할당(사용)이 불가능한 상태를 말하다. 외부 단편화, 내부 단편화로 구분 가능하다.

  내부 단편화

  메모리 할당 시 프로세스가 필요한 양보다 더 큰 메모리가 할당 되어 프로세스에 사용하는 메모리 공간이 낭비되는 상황

  외부 단편화 

  메모리가 할당되고 해제되는 작업이 반복될 때 작은 메모리가 중간중간 존재 한게된다.

  이때 중간중간에 생긴 사용하지 않는 메모리가 많이 존재해서 총 메모리 공간은 충분하지만 실제로 할당 할 수 없는 상황 

  (8mb 프로세스 할당되고 바로 16mb프로세스 할당되었다 가정할때 8mb프로세스 종료시키면 메모리 처음 주소부터 8mb 공간이 생긴다) 이런 식으로 계속 빈 메모리가 쌓이는 데 예를 들어 가장 큰 빈 메모리가 8mb일 때 공간은 없지만 전체적으로 메모리 여유는 있을때 외부단편화가 생겼다고 한다.

- 메모리 단편화 해결방법

  압축

  메모리 공간들을 재배치하여, 단편화로 분산되어있는 메모리 공간들을 하나로 합치는 기법

  통합

  단편화로 인해 분산된 메모리공간들을 인전해 있는 것끼리 통합 시켜 큰 메모리 공간으로 합치는 기법. 압축은 재배치가 일어나지만 통합은 인접한 공간들 끼리 통합된다는 차이가 있다. 

  페이징 - 가상메모리사용, 외부단편화 해결

  페이지는 보조기억장치를 이용한 가상 메모리를 같은 크기의 블록으로 나눈것

  프레임은 주 기억장치를 페이지와 같은 크기로 나눈것

  페이징 기법은 사용하지 않는 프레임을 페이지에 옮기고 필요한 메모리를 페이지 단위로 프레임에 옮기는 기법(중기 스케줄링) 그러나 외부 단편화는 해결 되지만 내부단편화는 해결 안된다. 내부 단편화는 프로세스 크기가 페이지 크기의 배수가 아닌경우 마지막 페이지는 한프레임(페이지)를 다 채울 수 없어 발생하는 공간으로 메모리 낭비의 원인

  세그멘테이션 - 가상 메모리 사용, 내부 단편화 해결

  가상 메모리를 사용하는 것은 페이징과 유사. 같은 크기로 나누지 않고 서로 다른 크기로 나누는 단위 세그먼트라고 한다. 이를 이용한 메모리 관리 기법은 세그멘테이션 기법이다. 외부 단편화는 해결되지 않는다.

  의미있는 단위로 나누게 되면 보호와 공유를 하는 측면에서 이점을 가질 수 있게 된다. 세그먼트로 인한 외부 단편화 문제를 해결하기 위해 잘라진 세그먼트를 일정한 간격인 페이지 단위로 자르는 페이징 방법을 취한다. 이후 메모리에 적재하면 페이징의 일정 단위로 다시 잘렸기 때문에 외부 단편화가 발생하지 않는 다. 그러나 이러면 테이블을 두 가지 모두 거쳐야 함으로 속도가 조금 떨어진다.

  메모리 풀 - 내부 단편화, 외부 단편화 해결

  미리 할당 받아서 메모리 풀을 만들어 놓고 필요할 때마다 산용하고 반납하는 방법

  할당받았던 메모리 공간을 가져다 쓰고 반납하기 때문에 메모리 할당과 해제로 인한 외부 단편화가 생기지 않는다. 필요한 크기 만큼 할당을 해놓기 때문에 내부 단편화가 생기지 않는 다.  내부 단편화와 외부 단편화는 생기지 않지만 미리 할당해 놓고 사용하지 않는 순간에도 역시 메모리 누수가 일어나는 것이므로 잦은 동적 할당과 해제가 일어날 경우에 사용하는 것이 바람직 하다.



## 가상 메모리

가상 메모리의 역할은 뭔가요?

메모리가 실제 메모리 보다 많아 보이게 하는 기술로 어떤 프로세스가 실행될때 메모리에 해당 프로세스 전체가 올라가지 않아도 실행 가능하다는 점에서 고안되었다. 즉 물리적 메모리 크기의 한계를 극복하기 위해 나온 기술이다. 

- 장점

  프로그램의 크기가 물리적 용량에 무관

  더 많은 프로그램이 메모리를 공유하여 CPU 사용률과 처리율을 향상

  주소 결속을 실행 시간에 할 수 있다.

  페이지 부재율을 낮추면 성능이 높아진다.

- 단점

​		가상메모리를 사용할 경우 물리 메모리로 프로그램을 구동하는 것 보다 		속도가 		느림



mmu: CPU코어 안에서 가상 주소를 실제 메모리 주소로 변환해주는 장치



요구페이징이란?

CPU가 해당 페이지를 요구할 때까지 그 페이지를 메모리에 올리지 않는 방식

페이지 부재가 발생하면 그 때 트랩을 걸어 해당 페이지를 적재 

**Pure Demand Paging**: 프로세스를 실행할 때 어떠한 페이지도 메모리에 올리지 않고 시작

**pre-paging**: 우선 필요할 것 같은 페이지를 메모리에 올려놓고 나중에 다른 페이지가 필요하면 다른 페이지를 메모리에 올리는 방법

캐시 메모리 사용하는 이유

속도가 빠른 장치와 느린 장치 간의 속도차에 따른 병목 현상을 줄이기 위한 범용 메모리다.

메인 메모리와 CPU 사이에 위치하며, CPU의 속도에 버금갈 만큼 메모리 계층에서 가장 속도가 빠르지만, 용량이 적고 비싸다는 점도 있다. 

캐시 메모리는 메인 메모리에서 자주 사용하는 프로그램과 데이터를 저장해두어 속도를 빠르게 한다. 

#### ***\*캐시(Cache)의 지역성(Locality)\****

지역성이란, **데이터 접근이 시간적, 혹은 공간적으로 가깝게 일어나는 것**

**시간적 지역성**

- 특정 데이터가 한번 접근되었을 경우, 가까운 미래에 또 한번 데이터에 접근할 가능성이 높은 것

**공간적 지역성**

- 공간 지역성은 특정 데이터와 가까운 주소가 순서대로 접근되는 경우를 말합니다.



레지스터와 캐시의 차이

캐시는 **cpu와 별도**로 있는 공간이며, **메인 메모리와 cpu 간의 속도 차이를 극복**하기 위한 것 레지스터는 **cpu 안에서 연산을 처리하기 위하여 데이터를 저장하는 공간**



## 커널

- 커널이란

  운영체제처럼 규모가 큰 프로그램이 모두 메모리에 올라간다면 한정된 메모리 공간의 낭비가 심할것이다. 따라서 운영체제 중 **항상 필요한 부분**만을 전원이 켜짐과 동시에 메모리에 올려놓고 그렇지 않은 부분은 필요할 때 메모리에 올려서 사용하게 된다. 이 때 **메모리에 상주하는 운영체제의 부분을 커널**이라 한다. 또 이것을 좁은 의미의 운영체제라고도 한다. 즉 커널은 메모리에 상주하는 부분으로써 운영체제의 핵심적인 부분을 뜻한다.

- 커널 수준 스레드와 사용자 수준 스레드의 장단점

  커널수준 스레드는 운영체제 시스템 내에서 생성되어 동작하는 스레드로, 커널이 직접 관리한다. 그런데 커널 수준에서는 프로세스가 주기억 장치에 여러 개가 적재되어 CPU 할당을 기다리며 동작한다. CPU에서 인터럽트 발생으로 현재 작업 중인 프로세스가 Block 되고 다른 프로세스로 변경할 때, CPU 내 재배치 레지스터에 다음에 실행할 프로세스 정보들로 교체를 하고 캐시를 비운다. 이 것을 **컨텍스트 스위칭**이라고 한다.

  이 컨텍스트 스위칭이 일어날 때는 CPU가 일을 못한다. 그래서 이게 자주 일어나면 성능에 영향이 발생하게 되는 단점이 있다.
  하지만 **커널이 직접 관리하므로 특정 스레드가 Block이 되어도 다른 스레드들은 독립적으로 일을 할 수 있다.**

  장점: 커널이 각 스레드를 개별적으로 관리 함으로 프로세스 내 스레드들이 병행으로 수행이 가능 그래서 하나의 스레드가 중단 되어도 다른 스레드는 계속 수행이 가능하다.

  단점: 사용자 수준 스레드 보다 생성 및 관리 속도가 느리다

  사용자 수준의 스레드는  스레드를 관리하는 라이브러리로 인해 사용자 단에서 생성 및 관리되는 스레드이다. 그래서 커널이 따로 관리하지 않고, 커널이 이 스레드에 대해서 알지도 못한다.

  장점: 커널에 독립적으로 스케줄링을 할 수 있어 모든 운영체제에 적용할 수 있다. 이식성이 높다. 스케줄링이나 동기화를 위해 커널을 호출하지 않으므로, 커널 영역으로 전환하는 오버헤드가 줄어든다. 커널이 아닌 스레드 라이브러리에서 스레드 스케줄링을 제어하므로, 유연한 스케줄링이 가능하다. 

  단점: 하나의 프로세스로부터 할당된 여러개의 스레드들 중, 한 스레드가 대기 상태가 되면, 모든 스레드들을 실행시킬 수 없게 된다. 커널이 스레드 관리에 개입하지 않으므로, 스레드 간 보호에 커널의 보호 방법을 사용할 수 없다. 라이브러리 수준의 보호 방법까지만 사용 가능하다.

- 인터럽트가 필요한 이유와 언제 발생되는 지?

  필요한 이유

  CPU 수행 능력 극대화 하기 위해서 이다.

  입출력 연산은 CPU 명령수행 속도보다 현저히 느리기 때문. 상대적으로 속도가 느린 입출력 연산을  CPU가 기다리면 효율이 떨어짐. 그래서 운영체제는 연산 결과가 나올 때 까지 CPU에 다른 일을 수행 하도록 하고 연산 작업이 끝나면 작업 완료를 알려 cPU가 다시 해당 작업을 이어서 할 수 있도록 함.

  인터럽트는 프로그램을 실행하는 도중에 예기치 않은 상황이 발생할경우 현재 실행중인 작업을 즉시 중단하고 발생된 상황을 우선 처리한 후 실행중이던 작업으로 복귀하여 계속 처리하는것을 말합니다.

  외부 인터럽트(언제발생: 입출력, 전원같은 외부요인)

  **전원 이상 인터럽트 :** 정전이되거나 전원 이상이 있는경우 발생합니다.

  **기계 착오 인터럽트 :** CPU의 기능적인 오류 동작이 발생한 경우 발생합니다.

  **외부 신호 인터럽트 :** 타이머에 의해 규정된 시간을 알리는경우, 키보드로 인터럽트 키를 누른 경우, 외부 장치로부터 인터럽트 요청이 있는경우 발생합니다.

  **입출력 인터럽트 :** 입출력 Data의 오류나 이상 현상이 발생한 경우, 입출력장치가 데이터의 전송을 요구하거나 전송을 끝났음을 알릴경우 발생합니다.

  내부 인터럽트 (트랩이라고도한다. )(언제발생: 잘못된명령)

  **프로그램 검사 인터럽트 :** 0으로 나누기가 발생한 경우, OverFlow 또는 UnderFlow가 발생한경우, 프로그램에서 명령어를 잘못 사용한 경우,  존재하지 않는 메모리 주소에 접근하는 경우와 같은 프로그램 상의 오류가 발생합니다.

- 시스템콜이란 무엇이며 사용 이유

  운영 체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스이다. 

  우리가 일반적으로 사용하는 프로그램은 '응용프로그램'입니다. 유저레벨의 프로그램은 유저레벨의 함수들 만으로는 많은 기능을 구현하기 힘들기 때문에, 커널(kernel)의 도움을 반드시 받아야 합니다. 이러한 작업은 응용프로그램으로 대표되는 유저 프로세스(User Process)에서 유저모드에서는 수행할 수 없습니다. 반드시 kernel에 관련된 것은 커널모드로 전환한 후에야, 해당 작업을 수행할 권한이 생깁니다. 

  커널 모드를 통한 이러한 작업은 반드시 시스템 콜을 통해 수행하도록 설계되어 있습니다.

  그렇다면 권한이 필요한 이유는 해커가 피해를 입히기 위해 악의적으로 시스템 콜을 사용하는 경우나 초보 사용자가 하드웨어 명령어를 잘 몰라서 아무렇게 함수를 호출했을 경우에 시스템 전체를 망가뜨릴 수도 있기 때문입니다.

- 서브루틴과 시스템 콜 차이

  서브루틴은 반복되어 사용하는 것을 메모리에 한번 적재하여 여러번 사용할 수 있도록 하는 방법이다. 그러므로 기억장소를 절약할 수 있다.

  서브루틴은 완전한 프로그램과 상호 관계를 가질 수 있는 한 프로그램의 독립적인 부분들. 하나의 서브루틴은 주 프로그램의 임의 지점으로부터 주 프로그램으로 들어갈 수 있고, 일반적으로 서브루틴이 다 끝났을 때 되돌아가는 지점은 자동적으로 서브루틴으로 들어온 분기점 바로 다음 명령이 된다.

  서브루틴을 사용하는 2가지 중요한 이유는 다음과 같다. ㉠어떤 루틴들은 여러 프로그램의 일반적인 특성을 띠며 공통적인 면도 가진다. 예를 들면, 제곱근과 같은 수학적인 함수의 계산과 입출력 장치의 제어와 연관된 루틴들이 바로 이것이다. 일반적으로 이러한 형태의 서브루틴들은 컴퓨터와 함께 주어진 소프트웨어의 한 부분으로서 제조 회사에서 제공한다. ㉡어떤 특정한 프로그램은 주 프로그램의 여러 곳에서 요구된다. 이러한 부분들이 서브루틴으로 만들어져 그들이 요구될 때마다 여러 번 반복하지 않고 한 번만 저장함으로써 기억 장소 절약할 수 있다.

  서브루틴을 사용하는 목적은 다음과 같다. ㉮미리 프로그램되고 점검된 서브루틴들을 사용함으로써 프로그램 작성 더 쉽게, 그리고 더 빨리 하기 위해서 사용된다. ㉯프로그램 또는 그 프로그램의 일부를 한 번만 적재하여 주 프로그램에서 필요로 할 때에만 이 서브루틴으로 분기시킴으로써 기억 장소를 절약할 수 있다. 

  

  

- **인터럽트와 서브루틴의 차이**
  서브루틴은 자신을 **호출한 프로그램**이 요구한 기능을 수행.
  인터럽트 처리 프로그램은 인터럽트가 발생했을 때 실행 중인 프로그램과 **관련이 없을 수** 있음. 그렇기 때문에 인터럽트는 서브루틴과 다르게 나중에 다시 그 프로그램에 복귀했을 때를 위해 정보를 저장해놓는다.



