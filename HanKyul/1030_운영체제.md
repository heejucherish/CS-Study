## Deadlock

프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태 (교착 상태)

- 발생 조건
    - 상호 배제
        - 프로그램이 자원을 점유하는 데 있어서 배타적
        - 자원 자체를 동시에 쓸수 없음
    - 점유 상태로 대기
        - 자원을 붙잡은 상태에서 다른 자원을 기다림
    - 선점 불가
        - 이미 할당된 자원을 강제로 빼앗을 수 없음
        - 선점하고 있는 프로세스가 죽어버린다면..
    - 순환성 대기
        - 대기가 꼬리를 물고 사이클이 되는 경우
        - 자기 자신이 잡고있는 자원을 기다리는 경우

## 외부 단편화 내부 단편화

- 내부 단편화
    - 주기억장치 내 사용자 영역이 실행 프로그램보다 큰 경우
    - 공간이 남아버림
    - ex) 100mb 공간에 80mb 프로세스 적재 시
- 외부 단편화
    - 내부 단편화의 반대 경우
    - 남은 메모리 공간은 분명 프로세스보다 큰데, 나눠져 버려서 적재할 수 없는 경우
    - 압축을 통해 해결가능
        - 단편화 된 공간을 통합함

![](IMG_1029/%EC%99%B8%EB%B6%80%EB%8B%A8%ED%8E%B8.JPG)
외부

![](IMG_1029/%EB%82%B4%EB%B6%80%EB%8B%A8%ED%8E%B8%ED%99%94.jfif)
내부

## 단편화 해결

- 페이징 - 외부 단편
- 압축 - 외부 단편
- 세그멘테이션 - 내부 단편화
- 메모리 풀
    
    필요한 메모리 공간을 크기, 개수만큼 사용자가 직접 지정
    
    미리 할당받아 놓고 필요할 때마다 사용 / 반납하는 기법
    
    미리 할당해놓고 사용하지 않으면 → 결국 누수임
    
    할당 / 해제가 잦으면 유리한 기법임

## 페이징 기법의 장단점
#### 페이징 기법이란
- 논리주소의 고정된 페이지라고 불리는 블록들로 분할 관리하는 기법
  - Logical Address == physical address 같은 크기로 자름
- 각각의 페이지는 물리 메모리의 프레임과 맵핑
- 페이지를 가리키는 논리주소 -> 프레임을 가리키는 물리주소로 변환
<br>
- **요약 : 프로세스를 일정 크기인 페이지로 잘라서 메모리에 적재한다!**

![](IMG_1029/%ED%8E%98%EC%9D%B4%EC%A7%95.JPG)

#### 장점
* 외부 단편화가 해결될 수 있다
  * 남는 공간 없이 프로세스들이 잘라져 남는 프레임에 적재되므로

* 단점
  * 내부 단편화가 발생할 수 있다
    * 프레임이 고정되므로
    * 더 작게 쪼개면 된다?
      * 오히려 비효율적일 수 있다


## 가상 메모리
### 가상 메모리란
* 보조 기억 장치 (디스크)의 일부분을 주기억장치처럼 사용하는 것
* 이를 위해선 MMU(Memory Management Unit)이 필요
  * 가상 주소 -> 물리 주소로 변환
  * 메모리를 보호
  * CPU가 메모리 접근 전에 주소 번역 작업을 수행

### 요구 페이징
* 필요한 프로그램만 메모리에 적재하는 방법
* (페이징 기법에서 봤듯이) 프로세스는 페이지의 조합이므로 가능함
  * 요구되는 페이지만 메모리에 올린다는 의미

* 가상 메모리랑 무슨 관계?
  * 필요한 페이지는 - 메인 메모리에
  * 당장 필요하지 않으면 - backing store(가상 메모리)에
    * 이 둘을 구분지어야 함
    * valid bit를 사용
  * 가상 메모리에 있는 페이지가 필요한 경우에
    * 페이지를 찾아 메인 메모리에 적재
    * valid bit를 통해 메인 메모리에 위치함을 표시

* 요구 페이징의 종류
  * pure demang paging
    * 모든 페이지를 적재하지 않고 cpu가 요구할 때 페이지를 적재하는 방식
    * 메모리의 낭비가 줄어듦
    * 속도면에서 불리
  * prepaging
    * 필요할 것 같은 페이지를 적재시키고 필요시 페이지 교체
    * 속도가 빠름
    * 메모리가 낭비될 수 있음

## Cache 메모리
* 캐시 메모리란
  * CPU가 주기억장치에서 저장된 데이터를 읽을 때
  * 자주 사용하는 데이터를 캐시 메모리에 저장
  * 캐시 메모리에서 데이터를 읽어옴으로써 속도 향상
  * 이로서 병목 현상을 줄일 수 있음

* 캐시의 지역성
  * 캐시의 적중률을 높이기 위해 사용
  * 공간 지역성
    * 최근에 사용됐던 데이터와 인접한 데이터가 재참조될 것이다
  * 시간 지역성
    * 최근에 사용됐던 데이터가 재참조될 가능성이 높다

## 커널이란
* 운영체제 중 항상 메모리에 올라가 있는 운영체제의 핵심 부분
* 하드웨어 ~ 응용 프로그램 사이의 인터페이스 제공
* **컴퓨터의 자원 관리**
* 사용자와의 직접적인 상호작용 X
  * Shell등의 명령어 해석기로 소통

<br>

* 요약하자면 **사용자가 System Call을 통해 컴퓨터 자원을 사용할 수 있게 해주는 자원 관리자다**

## 커널 수준 스레드와 사용자 수준 스레드
* 생성 주체에 따라 구분됨
#### 커널 수준 스레드
* 운영체제 내에서 생성, 동작되는 스레드
* 커널이 직접 관리

* 장단점
  * 커널이 직접 제공하기 때문에 안정적
  * 유저모드 - 커널모드의 전환이 빈번하게 이루어져 성능 저하


#### 사용자 수준 스레드
* 스레드를 관리하는 라이브러리 사용
* 사용자 단에서 생성 / 관리되는 스레드
* 장단점
  * 성능 이득 (유저모드 - 커널모드 전환 X)
  * 스레드가 커널에 의해 블록 -> 프로세스 전체가 블로킹 : 프로그래밍이 어려워짐


## 인터럽트가 필요한 이유

#### 인터럽트란
* CPU가 특정 기능을 수행 중 급하게 다른 일을 처리하고자 할 때 필요
* CPU가 프로그램 실행 시 -> 하드웨어 이슈가 발생 -> 운영체제에 알림 -> 해당 프로세스 대기
* 혹은 예외 발생시..

#### 인터럽트의 종류
* 외부
  * 입출력, 타이밍, 전원 등 외부요인에 의해 발생하는 인터럽트
    * 전원 이상
    * 기계 고장
    * 입출력
* 내부
  * 잘못된 명령 / 데이터 사용 시
    * 0으로 나누기
    * 오버/언더플로우
    * 프로그램 오류

## 시스템 콜이란?
* 커널 영역의 기능을 사용자 모드가 사용 가능하게 함
  * 즉 프로세스가 하드웨어에 직접 접근, 필요한 기능을 사용할 수 있게 함

* 예시
  * 파일 열기 / 닫기 / 읽기 / 쓰기
  * 프로세스 제어 (끝내기, 중지, 적재 등)
  * 장치 관리
  * 통신

## 시스템 콜과 서브루틴의 차이
* API를 호출한다 는 의미상으론 비슷해 보임
* 하지만 다른 점은
  * 만약 서브루틴을 호출했을 때
  * 하드웨어 접근 등의 이유로 시스템 콜을 사용해야 한다면
  * 결국 서브루틴이 시스템 콜을 호출하는 형태가 됨

* 즉
  * 서브루틴 -> 시스템 콜 -> 커널 -> 하드웨어 제어
  * 의 형식이 됨
    * 단, 모든 서브루틴 != 시스템 콜
    * 필요한 경우에 시스템 콜을 함